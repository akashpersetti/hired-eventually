from __future__ import annotations

import asyncio
import json
import os
from pathlib import Path

import anthropic
from dotenv import load_dotenv
from openai import OpenAI
from pydantic import BaseModel, Field
from pypdf import PdfReader

from agents.mcp import MCPServerStdio


load_dotenv(override=True)


class CoverLetter(BaseModel):
    cover_letter: str = Field(description="The cover letter output")
    company_name: str = Field(description="The company name from the job description")


_MCP_PARAMS = {"command": "npx", "args": ["cv-forge"]}


def _read_resume_text(resume_pdf_path: str | Path) -> str:
    """Read and concatenate text from all pages in the resume PDF."""
    path = Path(resume_pdf_path)
    if not path.is_file():
        raise FileNotFoundError(f"Resume PDF not found at: {path}")

    reader = PdfReader(str(path))
    resume_text_parts: list[str] = []
    for page in reader.pages:
        page_text = page.extract_text() or ""
        resume_text_parts.append(page_text)
    return "\n".join(resume_text_parts).strip()


def _build_basic_user_profile(resume_text: str) -> dict:
    """
    Build a minimal cv-forge-compatible userProfile object from resume text.

    This does not try to perfectly parse the resume - it just provides enough
    structure for cv-forge to work, while the selected model does the final polishing.
    """
    summary = resume_text.splitlines()[0].strip() if resume_text.strip() else "Software professional."

    return {
        "personalInfo": {
            "fullName": "Akash Hadagali Persett",
            "email": "hadagalipersettiakash@gmail.com",
            "phone": "",
            "location": "",
            "linkedIn": "",
            "github": "",
            "website": "",
        },
        "summary": summary,
        "experience": [],
        "education": [],
        "skills": {
            "technical": [],
            "soft": [],
            "languages": [],
            "certifications": [],
        },
        "projects": [],
    }


async def _run_cv_forge(
    resume_text: str,
    job_description: str,
) -> tuple[str, dict]:
    """
    Call the cv-forge MCP server tools:

    - parse_job_requirements: structured requirements for the JD
    - generate_cover_letter: a draft cover letter text

    Returns (draft_cover_letter_text, job_requirements_object).
    """
    user_profile = _build_basic_user_profile(resume_text)
    # Let cv-forge infer job title and company from the description itself.
    # We pass neutral placeholders only to satisfy the schema.
    job_title = "Unknown role"
    company = "Unknown company"

    async with MCPServerStdio(
        params=_MCP_PARAMS,
        client_session_timeout_seconds=180,
    ) as server:
        job_reqs_call = await server.call_tool(
            "parse_job_requirements",
            arguments={
                "jobTitle": job_title,
                "company": company,
                "jobDescription": job_description,
            },
        )
        job_reqs_text = job_reqs_call.content[0].text
        try:
            job_reqs = json.loads(job_reqs_text)
        except json.JSONDecodeError:
            job_reqs = {
                "jobTitle": job_title,
                "company": company,
                "jobDescription": job_description,
            }
        else:
            job_reqs.setdefault("jobDescription", job_description)

        cover_call = await server.call_tool(
            "generate_cover_letter",
            arguments={
                "userProfile": user_profile,
                "jobRequirements": job_reqs,
                "format": "text",
            },
        )
        draft_cover = cover_call.content[0].text

    return draft_cover, job_reqs


def _build_final_prompt(
    resume_text: str,
    job_description: str,
    job_requirements: dict,
    cv_forge_draft: str,
) -> str:
    """
    Prompt template for providers we call directly (GPT-5.2, Claude, Gemini).

    The selected model receives:
    - raw resume text
    - raw job description
    - structured job requirements from cv-forge
    - a draft cover letter generated by cv-forge
    """
    job_requirements_json = json.dumps(job_requirements, indent=2)

    return f"""
You are a professional cover letter writer.

You will receive:
- The candidate's resume text
- The full job description
- Structured job requirements extracted by a tool (cv-forge)
- A draft cover letter generated by the same tool

Your task:
- Use ALL of this context to write a polished, specific, and human-sounding cover letter.
- Improve, reorganize, and refine the cv-forge draft rather than ignoring it.

Requirements:
- Professional tone. No clichés ("passionate", "team player").
- No em-dashes (—); use a regular hyphen (-) instead.
- Do not ask questions at the end.
- If the job description lists multiple roles, write ONE letter that reasonably fits all of them.
- If describing the Sentinel project, mention "Agentic AI" in the description.

Output format (CRITICAL):
Respond with valid JSON only, using exactly this shape:
{{
  "cover_letter": "<full cover letter text>",
  "company_name": "<company name from the job description>"
}}

Do NOT include markdown, commentary, or any keys other than `cover_letter` and `company_name`.

RESUME TEXT:
{resume_text}

JOB DESCRIPTION:
{job_description}

JOB REQUIREMENTS (from cv-forge):
{job_requirements_json}

DRAFT COVER LETTER (from cv-forge - improve this):
{cv_forge_draft}
"""


def _parse_cover_letter_json(raw_text: str) -> CoverLetter:
    """
    Parse the model JSON response into a CoverLetter.

    If parsing fails, fall back to treating the whole text as the cover letter
    and leave company_name empty.
    """
    try:
        data = json.loads(raw_text)
        cover_letter = str(data.get("cover_letter", "")) or raw_text
        company_name = str(data.get("company_name", "") or "")
    except json.JSONDecodeError:
        cover_letter = raw_text
        company_name = ""
    return CoverLetter(cover_letter=cover_letter, company_name=company_name)


async def _generate_with_gpt(
    resume_text: str,
    job_description: str,
) -> CoverLetter:
    """
    Generate a cover letter using OpenAI's GPT-5.2 via the OpenAI() client,
    while still leveraging the cv-forge MCP tools.
    """
    cv_forge_draft, job_reqs = await _run_cv_forge(resume_text, job_description)
    prompt = _build_final_prompt(resume_text, job_description, job_reqs, cv_forge_draft)

    client = OpenAI()  # Uses OPENAI_API_KEY from the environment

    response = await asyncio.to_thread(
        client.chat.completions.create,
        model="gpt-5.2",
        messages=[{"role": "user", "content": prompt}],
    )

    raw_text = str(response.choices[0].message.content)
    return _parse_cover_letter_json(raw_text)


async def _generate_with_claude(
    resume_text: str,
    job_description: str,
) -> CoverLetter:
    """
    Generate a cover letter using Anthropic Claude directly,
    while still leveraging the cv-forge MCP tools.
    """
    cv_forge_draft, job_reqs = await _run_cv_forge(resume_text, job_description)
    prompt = _build_final_prompt(resume_text, job_description, job_reqs, cv_forge_draft)

    client = anthropic.Anthropic()

    message = await asyncio.to_thread(
        client.messages.create,
        model="claude-sonnet-4-0",
        max_tokens=4096,
        messages=[{"role": "user", "content": prompt}],
    )

    raw_text = "".join(
        part.text for part in message.content if getattr(part, "text", None)
    )
    return _parse_cover_letter_json(raw_text)


async def _generate_with_gemini(
    resume_text: str,
    job_description: str,
) -> CoverLetter:
    """
    Generate a cover letter using Gemini via the OpenAI-compatible API,
    while still leveraging the cv-forge MCP tools.
    """
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("GOOGLE_API_KEY is not set in the environment.")

    cv_forge_draft, job_reqs = await _run_cv_forge(resume_text, job_description)
    prompt = _build_final_prompt(resume_text, job_description, job_reqs, cv_forge_draft)

    client = OpenAI(
        api_key=api_key,
        base_url="https://generativelanguage.googleapis.com/v1beta/openai/",
    )

    response = await asyncio.to_thread(
        client.chat.completions.create,
        model="gemini-3-flash-preview",
        messages=[{"role": "user", "content": prompt}],
    )

    raw_text = str(response.choices[0].message.content)
    return _parse_cover_letter_json(raw_text)


async def generate_cover_letter(
    resume_pdf_path: str | Path,
    job_description: str,
    model: str,
) -> CoverLetter:
    """
    Generate a tailored cover letter using the selected model.

    All models:
    - Use the cv-forge MCP tools `parse_job_requirements` and `generate_cover_letter`
      to build structured job requirements and a draft cover letter.
    - Then call the chosen provider (GPT-5.2, Claude, or Gemini) to produce the final
      JSON-shaped `CoverLetter` output.
    """
    resume_text = _read_resume_text(resume_pdf_path)

    if model == "gpt-5.2":
        return await _generate_with_gpt(resume_text, job_description)
    if model == "claude-sonnet-4-0":
        return await _generate_with_claude(resume_text, job_description)
    if model == "gemini-3-flash-preview":
        return await _generate_with_gemini(resume_text, job_description)

    raise ValueError(f"Unsupported model: {model}")


async def generate_cover_letter_text(
    resume_pdf_path: str | Path,
    job_description: str,
    model: str,
) -> str:
    """Convenience wrapper that returns only the cover letter text."""
    output = await generate_cover_letter(resume_pdf_path, job_description, model)
    return output.cover_letter
